function puntosQueOtorgaLaBombaAca() {
    /*
        PROPÓSITO: Describe la cantidad de puntos que se obtendrian si la bomba explotara en la celda actual
        TIPO: Numero
        PRECONDICIONES:
            * Debe haber una bomba en la celda actual
            * Los bordes del tablero deben tener bloques de concreto
    */
    direccion:= minDir()
    puntosAcumulados:= puntosQueOtorgaLaBombaPropagandoHacia_(direccion)
    while(direccion/= maxDir()){
        direccion := siguiente(direccion)
        puntosAcumulados:= puntosAcumulados + puntosQueOtorgaLaBombaPropagandoHacia_(direccion)
    }
    return ( puntosAcumulados )
}

function puntosQueOtorgaLaBombaPropagandoHacia_(direccion){
    /*
        PROPÓSITO: Describe la cantidad de puntos que se obtendrian si la bomba explotara en la celda actual 
        propagando hacia **direccion**
        TIPO: Numero
        PARAMETROS: 
            * direccion - Direccion - La direccion hacia la cual se propaga la bomba
        PRECONDICIONES:
            * Debe haber una bomba en la celda actual
            * Los bordes del tablero deben tener bloques de concreto
    */    
    puntajeASumar := 0
    repeat(distanciaAPropagarHacia_ConPotencia(direccion, potencia(bombaAca()))){
        Mover(direccion)
        puntajeASumar:= puntajeASumar + puntaje(ubicacionAca())
    }
    return(puntajeASumar)
}

function cantidadDeEnemigosEnLaGrilla() {
    /*
        PROPÓSITO:  Describe la cantidad de enemigos que hay en la grilla
        TIPO: Numero
        PRECONDICIONES: Ninguna

    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este,Norte)
    cantidadDeEnemigos := 0
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este,Norte)){
        cantidadDeEnemigos:= cantidadDeEnemigos + cantidadDeEnemigosAca()
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este,Norte)
    }
    return (cantidadDeEnemigos + cantidadDeEnemigosAca())
}

function cantidadDeEnemigosAca() {
    /*
        PROPÓSITO:  Describe la cantidad de enemigos que hay en la celda actual
        TIPO: Numero
        PRECONDICIONES: Ninguna
    */
    return (choose cantidad(enemigoAca()) when hayEnemigo()
                    0 otherwise)
}

function hayEnemigo() {
    /*
        PROPÓSITO:  Indica si hay enemigos en hay en la celda actual
        TIPO: booleano
        PRECONDICIONES: Ninguna
    */
    return ( hayPersonaje() && personajeAca() == Enemigo)
}

function hayPersonaje() {
    /*
        PROPÓSITO:  Indica si hay personaje en hay en la celda actual
        TIPO: booleano
        PRECONDICIONES: Ninguna
    */
    return ( objeto(ubicacionAca()) == Personaje)
}

procedure PlantarBombasAvanzado() {
    /*
        PROPÓSITO:  Planta bombas avanzando en direccion hacia donde mira bomberman hasta encontrar obstaculo
        o quedarse sin fuerza
        PRECONDICIONES:
            * Bomberman debe estar en la celda actual
            *Los bordes del tablero deben tener bloques de concreto
    */

    while(not hayObstaculoOEnemigoDondeMiraBomberman() && fuerza(bombermanAca())>0){
        PlantarBomba_(Bomba(potencia <- fuerza(bombermanAca())))
        MoverBombermanRestandoFuerza()
    }
    PlantarBombaSiTieneFuerza()
}

procedure MoverBombermanRestandoFuerza() {
    /*
        PROPÓSITO: Mover a bomberman en direccion hacia donde mira, restandole 1 de fuerza.
        PRECONDICIONES:
            * Bomberman debe estar en la celda actual
            * Debe haber al menos una celda libre hacia donde mira bomberman
    */
    bomberman:= bombermanAca()
    SacarPersonaje()
    Mover(direccionDondeMira(bomberman))
    PonerPersonaje_(Bomberman(bomberman| fuerza <- (fuerza(bomberman)-1)))
}

procedure PlantarBombaSiTieneFuerza() {
    /*
        PROPÓSITO:  Planta bomba en la celda actual si bomberman si tiene fuerza
        PRECONDICIONES:
            * Bomberman debe estar en la celda actual
    */
    if(fuerza(bombermanAca())>0){
        PlantarBomba_(Bomba(potencia <- fuerza(bombermanAca())))
    }
}